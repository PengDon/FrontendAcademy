# 设计模式

本目录包含设计模式的学习资料，帮助开发者理解和应用软件设计中经典的设计模式，提高代码的可重用性、可维护性和灵活性。

## 📁 目录结构

```
design-patterns/
├── creational/         # 创建型模式
│   ├── singleton/      # 单例模式
│   ├── factory/        # 工厂模式
│   ├── abstract-factory/ # 抽象工厂模式
│   ├── builder/        # 建造者模式
│   └── prototype/      # 原型模式
├── structural/         # 结构型模式
│   ├── adapter/        # 适配器模式
│   ├── decorator/      # 装饰器模式
│   ├── facade/         # 外观模式
│   ├── proxy/          # 代理模式
│   └── composite/      # 组合模式
└── behavioral/         # 行为型模式
    ├── observer/       # 观察者模式
    ├── strategy/       # 策略模式
    ├── command/        # 命令模式
    ├── iterator/       # 迭代器模式
    └── state/          # 状态模式
```

## 📚 学习路径

### 基础阶段

1. **设计模式基础**
   - 理解设计模式的概念和分类
   - 掌握设计模式的核心原则（单一职责、开放封闭等）
   - 学习UML类图的基本表示方法

2. **常用创建型模式**
   - 单例模式：全局唯一实例的创建
   - 工厂模式：对象创建的封装
   - 建造者模式：复杂对象的构建

### 进阶阶段

1. **结构型模式**
   - 适配器模式：接口兼容性转换
   - 装饰器模式：动态功能扩展
   - 代理模式：对象访问控制

2. **行为型模式**
   - 观察者模式：一对多依赖关系管理
   - 策略模式：算法族封装与切换
   - 命令模式：请求封装与执行分离

### 高级阶段

1. **复杂设计模式应用**
   - 模式组合：多种模式协同工作
   - 反模式识别：避免常见设计陷阱
   - 设计模式的变体与扩展

2. **架构级应用**
   - 框架设计中的模式应用
   - 企业级应用中的模式选择
   - 性能与可维护性的平衡

## 🎯 核心知识点

### 创建型模式

- **单例模式（Singleton）**：确保一个类只有一个实例，并提供一个全局访问点
- **工厂模式（Factory）**：定义一个创建对象的接口，但由子类决定实例化的类
- **抽象工厂模式（Abstract Factory）**：提供一个创建一系列相关或相互依赖对象的接口
- **建造者模式（Builder）**：将复杂对象的构建与其表示分离
- **原型模式（Prototype）**：通过复制现有对象来创建新对象

### 结构型模式

- **适配器模式（Adapter）**：将一个类的接口转换成客户希望的另一个接口
- **装饰器模式（Decorator）**：动态地给对象添加一些额外的职责
- **外观模式（Facade）**：为子系统中的一组接口提供一个一致的界面
- **代理模式（Proxy）**：为其他对象提供一种代理以控制对这个对象的访问
- **组合模式（Composite）**：将对象组合成树形结构以表示"部分-整体"的层次关系

### 行为型模式

- **观察者模式（Observer）**：定义对象间的一种一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会得到通知并自动更新
- **策略模式（Strategy）**：定义一系列算法，把它们封装起来，并使它们可以互相替换
- **命令模式（Command）**：将请求封装为一个对象，从而使你可用不同的请求对客户进行参数化
- **迭代器模式（Iterator）**：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部表示
- **状态模式（State）**：允许一个对象在其内部状态改变时改变它的行为

## 💻 前端应用场景

### 创建型模式应用

1. **单例模式**：
   - 全局状态管理（如Redux store、Vuex store）
   - 配置管理对象
   - 应用程序日志记录器

2. **工厂模式**：
   - 动态组件创建
   - 表单元素生成器
   - 插件系统实现

3. **建造者模式**：
   - 复杂UI组件构建
   - 多步骤表单创建
   - 数据可视化图表配置

### 结构型模式应用

1. **适配器模式**：
   - API适配层
   - 第三方库集成
   - 跨浏览器兼容性处理

2. **装饰器模式**：
   - React高阶组件（HOC）
   - Vue混入（mixin）
   - 功能增强（如权限控制、日志记录）

3. **代理模式**：
   - 虚拟DOM代理
   - 请求缓存
   - 延迟加载（Lazy Loading）

### 行为型模式应用

1. **观察者模式**：
   - 事件处理系统
   - 发布-订阅模式实现
   - 响应式数据流

2. **策略模式**：
   - 表单验证策略
   - 排序算法切换
   - 主题切换功能

3. **命令模式**：
   - 撤销/重做功能
   - 操作历史记录
   - 用户行为日志

## 💡 学习建议

1. **理解意图**：掌握每个设计模式的核心意图和适用场景
2. **代码实现**：通过JavaScript/TypeScript实现各种设计模式
3. **识别应用**：在流行的前端框架中识别设计模式的应用
4. **避免过度设计**：根据实际需求选择合适的设计模式，避免为了使用模式而使用模式
5. **模式组合**：学习如何组合多种设计模式解决复杂问题

## 📚 设计模式原则

1. **单一职责原则（SRP）**：一个类应该只有一个引起它变化的原因
2. **开放封闭原则（OCP）**：软件实体应该对扩展开放，对修改关闭
3. **里氏替换原则（LSP）**：子类对象应该能够替换父类对象而不影响程序的正确性
4. **接口隔离原则（ISP）**：客户端不应该依赖它不需要的接口
5. **依赖倒置原则（DIP）**：高层模块不应该依赖低层模块，两者都应该依赖抽象
6. **合成复用原则（CRP）**：优先使用对象组合，而不是类继承

## 🔍 学习资源

- 《设计模式：可复用面向对象软件的基础》（GoF）
- 《JavaScript设计模式》
- 《前端设计模式与最佳实践》
- [Refactoring Guru](https://refactoringguru.cn/design-patterns/catalog)

## 🔗 相关链接

- [JavaScript设计模式实现](https://github.com/tcorral/Design-Patterns-in-JavaScript)
- [React设计模式](https://reactpatterns.com/)
- [Vue设计模式](https://vuejs.org/guide/reusability/plugins.html)